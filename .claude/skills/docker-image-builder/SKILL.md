# Docker Image Builder Skill

**Skill Name**: `docker-image-builder`
**Version**: 1.0.0
**Author**: AI-Assisted Development
**Last Updated**: 2025-12-28

## Purpose

A reusable skill for building optimized Docker images for full-stack applications with:
- **Frontend**: Next.js (React 19, TypeScript, Tailwind CSS)
- **Backend**: FastAPI with OpenAI Agents SDK
- **Target Environment**: Local Minikube Kubernetes cluster
- Multi-stage builds for production optimization
- Health checks, environment variables, and dependency management

## Prerequisites

### Required Tools
- Docker Desktop (running)
- Minikube (for local Kubernetes testing)
- Git (for commit-based tagging)
- Node.js 20+ (for frontend development)
- Python 3.11+ (for backend development)

### Project Structure
```
project-root/
â”œâ”€â”€ frontend/                 # Next.js application
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ next.config.js
â”‚   â”œâ”€â”€ src/
â”‚   â””â”€â”€ Dockerfile           # Generated by this skill
â”œâ”€â”€ backend/                  # FastAPI application
â”‚   â”œâ”€â”€ requirements.txt
â”‚   â”œâ”€â”€ pyproject.toml
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â””â”€â”€ main.py
â”‚   â””â”€â”€ Dockerfile           # Generated by this skill
â”œâ”€â”€ k8s/                      # Kubernetes manifests
â”‚   â”œâ”€â”€ frontend-deployment.yaml
â”‚   â”œâ”€â”€ frontend-service.yaml
â”‚   â”œâ”€â”€ backend-deployment.yaml
â”‚   â””â”€â”€ backend-service.yaml
â””â”€â”€ docker-compose.yml        # Optional: local development
```

---

## Step 1: Identify Frontend and Backend Directories

### Discovery Process

```bash
# Find frontend directory (Next.js indicators)
find . -name "next.config.*" -o -name "package.json" -exec grep -l "next" {} \;

# Find backend directory (FastAPI indicators)
find . -name "requirements.txt" -o -name "pyproject.toml" -exec grep -l "fastapi\|openai" {} \;
```

### Expected Configuration

| Component | Directory | Port | Health Endpoint |
|-----------|-----------|------|-----------------|
| Frontend  | `./frontend` or `./` (root) | 3000 | `/api/health` |
| Backend   | `./backend` | 8000 | `/health` |

---

## Step 2: Dockerfile Generation

### Frontend Dockerfile (Next.js Multi-Stage)

```dockerfile
# =============================================================================
# FRONTEND DOCKERFILE - Next.js Multi-Stage Build
# =============================================================================
# Stage 1: Dependencies
# Stage 2: Build
# Stage 3: Production Runtime
# =============================================================================

# -----------------------------------------------------------------------------
# Stage 1: Install Dependencies
# -----------------------------------------------------------------------------
FROM node:20-alpine AS deps

# Install libc6-compat for Alpine compatibility
RUN apk add --no-cache libc6-compat

WORKDIR /app

# Copy dependency files
COPY package.json package-lock.json* yarn.lock* pnpm-lock.yaml* ./

# Install dependencies based on lockfile
RUN \
  if [ -f yarn.lock ]; then yarn install --frozen-lockfile; \
  elif [ -f package-lock.json ]; then npm ci; \
  elif [ -f pnpm-lock.yaml ]; then corepack enable pnpm && pnpm install --frozen-lockfile; \
  else npm install; \
  fi

# -----------------------------------------------------------------------------
# Stage 2: Build Application
# -----------------------------------------------------------------------------
FROM node:20-alpine AS builder

WORKDIR /app

# Copy dependencies from deps stage
COPY --from=deps /app/node_modules ./node_modules
COPY . .

# Disable Next.js telemetry
ENV NEXT_TELEMETRY_DISABLED=1

# Build arguments for environment configuration
ARG NODE_ENV=production
ARG NEXT_PUBLIC_API_URL
ARG NEXT_PUBLIC_APP_VERSION

ENV NODE_ENV=${NODE_ENV}
ENV NEXT_PUBLIC_API_URL=${NEXT_PUBLIC_API_URL}
ENV NEXT_PUBLIC_APP_VERSION=${NEXT_PUBLIC_APP_VERSION}

# Build the application
RUN npm run build

# -----------------------------------------------------------------------------
# Stage 3: Production Runtime
# -----------------------------------------------------------------------------
FROM node:20-alpine AS runner

WORKDIR /app

# Set production environment
ENV NODE_ENV=production
ENV NEXT_TELEMETRY_DISABLED=1

# Create non-root user for security
RUN addgroup --system --gid 1001 nodejs && \
    adduser --system --uid 1001 nextjs

# Copy built assets
COPY --from=builder /app/public ./public
COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static

# Set correct ownership
RUN chown -R nextjs:nodejs /app

# Switch to non-root user
USER nextjs

# Expose port
EXPOSE 3000

# Set hostname for container networking
ENV HOSTNAME="0.0.0.0"
ENV PORT=3000

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:3000/api/health || exit 1

# Start the application
CMD ["node", "server.js"]
```

#### Next.js Configuration Required

Add to `next.config.js` for standalone output:

```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'standalone',
  // Enable if using server actions
  experimental: {
    serverActions: {
      allowedOrigins: ['localhost:3000'],
    },
  },
};

module.exports = nextConfig;
```

---

### Backend Dockerfile (FastAPI Multi-Stage)

```dockerfile
# =============================================================================
# BACKEND DOCKERFILE - FastAPI with OpenAI Agents SDK Multi-Stage Build
# =============================================================================
# Stage 1: Builder (install dependencies)
# Stage 2: Production Runtime
# =============================================================================

# -----------------------------------------------------------------------------
# Stage 1: Builder - Install Dependencies
# -----------------------------------------------------------------------------
FROM python:3.11-slim AS builder

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PIP_NO_CACHE_DIR=1 \
    PIP_DISABLE_PIP_VERSION_CHECK=1

WORKDIR /app

# Install build dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Create virtual environment
RUN python -m venv /opt/venv
ENV PATH="/opt/venv/bin:$PATH"

# Copy dependency files
COPY requirements.txt pyproject.toml* ./

# Install Python dependencies
RUN pip install --upgrade pip setuptools wheel && \
    pip install -r requirements.txt

# -----------------------------------------------------------------------------
# Stage 2: Production Runtime
# -----------------------------------------------------------------------------
FROM python:3.11-slim AS runner

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PYTHONFAULTHANDLER=1 \
    PATH="/opt/venv/bin:$PATH"

# Build arguments
ARG APP_VERSION=1.0.0
ARG BUILD_DATE

# Labels for OCI compliance
LABEL org.opencontainers.image.created="${BUILD_DATE}" \
      org.opencontainers.image.version="${APP_VERSION}" \
      org.opencontainers.image.title="Todo Backend API" \
      org.opencontainers.image.description="FastAPI backend with OpenAI Agents SDK"

WORKDIR /app

# Install runtime dependencies only
RUN apt-get update && apt-get install -y --no-install-recommends \
    curl \
    && rm -rf /var/lib/apt/lists/* \
    && apt-get clean

# Create non-root user
RUN groupadd --gid 1001 appgroup && \
    useradd --uid 1001 --gid appgroup --shell /bin/bash --create-home appuser

# Copy virtual environment from builder
COPY --from=builder /opt/venv /opt/venv

# Copy application code
COPY --chown=appuser:appgroup ./app ./app

# Switch to non-root user
USER appuser

# Expose port
EXPOSE 8000

# Environment variables (override at runtime)
ENV HOST=0.0.0.0 \
    PORT=8000 \
    WORKERS=2 \
    LOG_LEVEL=info

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=10s --retries=3 \
  CMD curl --fail http://localhost:8000/health || exit 1

# Start the application with uvicorn
CMD ["sh", "-c", "uvicorn app.main:app --host $HOST --port $PORT --workers $WORKERS --log-level $LOG_LEVEL"]
```

#### Backend Requirements File (requirements.txt)

```txt
# Core Framework
fastapi>=0.109.0
uvicorn[standard]>=0.27.0
pydantic>=2.5.0
pydantic-settings>=2.1.0

# OpenAI Agents SDK
openai>=1.12.0
openai-agents>=0.1.0  # If using agents SDK

# Database (optional)
sqlalchemy>=2.0.0
asyncpg>=0.29.0

# HTTP Client
httpx>=0.26.0
aiohttp>=3.9.0

# Utilities
python-dotenv>=1.0.0
python-multipart>=0.0.6

# Health & Monitoring
prometheus-fastapi-instrumentator>=6.1.0
```

#### Backend Health Endpoint (app/main.py)

```python
from fastapi import FastAPI
from pydantic import BaseModel
from datetime import datetime

app = FastAPI(title="Todo Backend API", version="1.0.0")

class HealthResponse(BaseModel):
    status: str
    timestamp: str
    version: str

@app.get("/health", response_model=HealthResponse)
async def health_check():
    return HealthResponse(
        status="healthy",
        timestamp=datetime.utcnow().isoformat(),
        version="1.0.0"
    )

@app.get("/")
async def root():
    return {"message": "Todo Backend API", "docs": "/docs"}
```

---

## Step 3: Build Images Locally

### Build Commands

```bash
# =============================================================================
# BUILD COMMANDS
# =============================================================================

# Set variables
export IMAGE_TAG=${IMAGE_TAG:-latest}
export REGISTRY=${REGISTRY:-local}
export BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
export GIT_SHA=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")

# -----------------------------------------------------------------------------
# Frontend Build
# -----------------------------------------------------------------------------
docker build \
  --tag todo-frontend:${IMAGE_TAG} \
  --tag todo-frontend:${GIT_SHA} \
  --build-arg NODE_ENV=production \
  --build-arg NEXT_PUBLIC_API_URL=http://todo-backend:8000 \
  --build-arg NEXT_PUBLIC_APP_VERSION=${IMAGE_TAG} \
  --label org.opencontainers.image.created="${BUILD_DATE}" \
  --label org.opencontainers.image.revision="${GIT_SHA}" \
  --label org.opencontainers.image.source="https://github.com/your-repo" \
  --file ./frontend/Dockerfile \
  --platform linux/amd64 \
  ./frontend

# -----------------------------------------------------------------------------
# Backend Build
# -----------------------------------------------------------------------------
docker build \
  --tag todo-backend:${IMAGE_TAG} \
  --tag todo-backend:${GIT_SHA} \
  --build-arg APP_VERSION=${IMAGE_TAG} \
  --build-arg BUILD_DATE="${BUILD_DATE}" \
  --label org.opencontainers.image.created="${BUILD_DATE}" \
  --label org.opencontainers.image.revision="${GIT_SHA}" \
  --label org.opencontainers.image.source="https://github.com/your-repo" \
  --file ./backend/Dockerfile \
  --platform linux/amd64 \
  ./backend

# -----------------------------------------------------------------------------
# Build Both (Combined Script)
# -----------------------------------------------------------------------------
# Save as: scripts/build-images.sh

#!/bin/bash
set -e

IMAGE_TAG=${1:-latest}
echo "ðŸ—ï¸  Building Docker images with tag: ${IMAGE_TAG}"

echo "ðŸ“¦ Building frontend..."
docker build -t todo-frontend:${IMAGE_TAG} -f ./frontend/Dockerfile ./frontend

echo "ðŸ“¦ Building backend..."
docker build -t todo-backend:${IMAGE_TAG} -f ./backend/Dockerfile ./backend

echo "âœ… Build complete!"
docker images | grep -E "todo-(frontend|backend)"
```

### Build Without Cache (Clean Build)

```bash
docker build --no-cache -t todo-frontend:latest -f ./frontend/Dockerfile ./frontend
docker build --no-cache -t todo-backend:latest -f ./backend/Dockerfile ./backend
```

---

## Step 4: Validate Images

### Run Containers Locally

```bash
# =============================================================================
# VALIDATION COMMANDS
# =============================================================================

# Create a network for container communication
docker network create todo-network 2>/dev/null || true

# -----------------------------------------------------------------------------
# Run Backend Container
# -----------------------------------------------------------------------------
docker run -d \
  --name todo-backend-test \
  --network todo-network \
  -p 8000:8000 \
  -e OPENAI_API_KEY=${OPENAI_API_KEY:-sk-test} \
  -e LOG_LEVEL=debug \
  todo-backend:latest

# Wait for backend to be ready
echo "â³ Waiting for backend to start..."
sleep 5

# Check backend health
curl -s http://localhost:8000/health | jq .

# -----------------------------------------------------------------------------
# Run Frontend Container
# -----------------------------------------------------------------------------
docker run -d \
  --name todo-frontend-test \
  --network todo-network \
  -p 3000:3000 \
  -e NEXT_PUBLIC_API_URL=http://todo-backend-test:8000 \
  todo-frontend:latest

# Wait for frontend to be ready
echo "â³ Waiting for frontend to start..."
sleep 10

# Check frontend health
curl -s http://localhost:3000/api/health | jq .

# -----------------------------------------------------------------------------
# Validation Script
# -----------------------------------------------------------------------------
# Save as: scripts/validate-images.sh

#!/bin/bash
set -e

echo "ðŸ” Validating Docker images..."

# Check images exist
echo "ðŸ“‹ Checking images..."
docker images | grep -E "todo-(frontend|backend)" || { echo "âŒ Images not found"; exit 1; }

# Check image sizes
echo "ðŸ“Š Image sizes:"
docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}" | grep -E "todo-(frontend|backend)|REPOSITORY"

# Test backend
echo "ðŸ§ª Testing backend container..."
docker run --rm -d --name backend-test -p 8000:8000 todo-backend:latest
sleep 5
BACKEND_HEALTH=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/health)
docker stop backend-test

if [ "$BACKEND_HEALTH" = "200" ]; then
  echo "âœ… Backend health check passed"
else
  echo "âŒ Backend health check failed (HTTP $BACKEND_HEALTH)"
  exit 1
fi

# Test frontend
echo "ðŸ§ª Testing frontend container..."
docker run --rm -d --name frontend-test -p 3000:3000 todo-frontend:latest
sleep 10
FRONTEND_HEALTH=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000)
docker stop frontend-test

if [ "$FRONTEND_HEALTH" = "200" ]; then
  echo "âœ… Frontend health check passed"
else
  echo "âŒ Frontend health check failed (HTTP $FRONTEND_HEALTH)"
  exit 1
fi

echo "ðŸŽ‰ All validations passed!"
```

### Health Check Endpoints

| Service | Endpoint | Expected Response |
|---------|----------|-------------------|
| Frontend | `GET /api/health` | `{"status": "ok"}` |
| Backend | `GET /health` | `{"status": "healthy", "timestamp": "...", "version": "..."}` |

### Cleanup Validation Containers

```bash
docker stop todo-frontend-test todo-backend-test 2>/dev/null || true
docker rm todo-frontend-test todo-backend-test 2>/dev/null || true
docker network rm todo-network 2>/dev/null || true
```

---

## Step 5: Tag Images for Kubernetes Deployment

### Tagging Strategy

```bash
# =============================================================================
# TAGGING FOR MINIKUBE DEPLOYMENT
# =============================================================================

# For Minikube, load images directly (no registry needed)
# Option 1: Use minikube docker-env
eval $(minikube docker-env)
docker build -t todo-frontend:latest -f ./frontend/Dockerfile ./frontend
docker build -t todo-backend:latest -f ./backend/Dockerfile ./backend

# Option 2: Load existing images into Minikube
minikube image load todo-frontend:latest
minikube image load todo-backend:latest

# Verify images are available in Minikube
minikube image list | grep todo

# -----------------------------------------------------------------------------
# For Remote Registry (DockerHub, GCR, etc.)
# -----------------------------------------------------------------------------
export REGISTRY=docker.io/yourusername
export VERSION=v1.0.0

# Tag for registry
docker tag todo-frontend:latest ${REGISTRY}/todo-frontend:${VERSION}
docker tag todo-frontend:latest ${REGISTRY}/todo-frontend:latest
docker tag todo-backend:latest ${REGISTRY}/todo-backend:${VERSION}
docker tag todo-backend:latest ${REGISTRY}/todo-backend:latest

# Push to registry
docker push ${REGISTRY}/todo-frontend:${VERSION}
docker push ${REGISTRY}/todo-frontend:latest
docker push ${REGISTRY}/todo-backend:${VERSION}
docker push ${REGISTRY}/todo-backend:latest
```

### Kubernetes Deployment Reference

Update your Kubernetes deployment manifests:

```yaml
# k8s/frontend-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: todo-frontend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: todo-frontend
  template:
    metadata:
      labels:
        app: todo-frontend
    spec:
      containers:
      - name: frontend
        image: todo-frontend:latest  # For Minikube local
        # image: docker.io/yourusername/todo-frontend:v1.0.0  # For registry
        imagePullPolicy: IfNotPresent  # Use Never for Minikube local
        ports:
        - containerPort: 3000
        env:
        - name: NEXT_PUBLIC_API_URL
          value: "http://todo-backend:8000"
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /api/health
            port: 3000
          initialDelaySeconds: 10
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /api/health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 10
```

```yaml
# k8s/backend-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: todo-backend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: todo-backend
  template:
    metadata:
      labels:
        app: todo-backend
    spec:
      containers:
      - name: backend
        image: todo-backend:latest
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 8000
        env:
        - name: OPENAI_API_KEY
          valueFrom:
            secretKeyRef:
              name: openai-secret
              key: api-key
        - name: LOG_LEVEL
          value: "info"
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 15
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 10
          periodSeconds: 10
```

---

## Best Practices Summary

### Security
- âœ… Use non-root users in containers
- âœ… Multi-stage builds to minimize attack surface
- âœ… No secrets in Dockerfiles (use environment variables)
- âœ… Minimal base images (Alpine/slim variants)
- âœ… Health checks for container orchestration

### Performance
- âœ… Layer caching optimization (dependencies before source)
- âœ… `.dockerignore` to reduce build context
- âœ… Production-optimized builds (NODE_ENV=production)
- âœ… Standalone output for Next.js

### Maintainability
- âœ… OCI-compliant labels for image metadata
- âœ… Semantic versioning with git SHA fallback
- âœ… Clear stage separation in multi-stage builds
- âœ… Documented environment variables

### .dockerignore Files

```dockerignore
# Frontend .dockerignore
node_modules
.next
.git
.gitignore
*.md
.env*
.vscode
coverage
.nyc_output
```

```dockerignore
# Backend .dockerignore
__pycache__
*.pyc
*.pyo
.git
.gitignore
*.md
.env*
.vscode
.pytest_cache
.coverage
htmlcov
venv
.venv
```

---

## Quick Reference Commands

```bash
# Build all images
./scripts/build-images.sh latest

# Validate images
./scripts/validate-images.sh

# Load into Minikube
eval $(minikube docker-env) && ./scripts/build-images.sh latest

# Check image sizes
docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}" | grep todo

# View image history/layers
docker history todo-frontend:latest
docker history todo-backend:latest

# Scan for vulnerabilities (requires Docker Scout or Trivy)
docker scout cves todo-frontend:latest
docker scout cves todo-backend:latest

# Clean up unused images
docker image prune -f
```

---

## Troubleshooting

### Common Issues

| Issue | Cause | Solution |
|-------|-------|----------|
| Build fails at npm install | Network or dependency issues | Use `--no-cache`, check package-lock.json |
| Image too large | Not using multi-stage build | Ensure standalone output, use Alpine base |
| Health check fails | App not ready or wrong port | Increase `start-period`, verify PORT env |
| Minikube can't find image | Image not loaded | Run `minikube image load <image>` |
| Permission denied | Running as root | Verify USER directive in Dockerfile |

---

## Version History

| Version | Date | Changes |
|---------|------|---------|
| 1.0.0 | 2025-12-28 | Initial release with Next.js + FastAPI support |
